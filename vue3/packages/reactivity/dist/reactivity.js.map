{
  "version": 3,
  "sources": ["../src/effect.ts", "../../shared/src/index.ts", "../src/baseHandler.ts", "../src/reactive.ts", "../src/computed.ts", "../src/watch.ts", "../src/ref.ts"],
  "sourcesContent": ["export let activeEffect = undefined\n\nfunction cleanupEffect(effect) {\n  let deps = effect.deps\n  for (let i = 0; i < deps.length; i++) {\n    deps[i].delete(effect)\n  }\n  effect.deps.length = 0\n}\n\nexport class ReactiveEffect {\n  parent = undefined\n  constructor(public fn, public scheduler?) {}\n  deps = []\n  run() {\n    try {\n      this.parent = activeEffect\n      activeEffect = this\n      cleanupEffect(this)\n      return this.fn()\n    } finally {\n      activeEffect = this.parent\n      this.parent = undefined\n    }\n  }\n}\n\nexport function effect(fn, options: any = {}) {\n  const _effect = new ReactiveEffect(fn, options.scheduler)\n  _effect.run()\n  const runner = _effect.run.bind(_effect)\n  return runner\n}\n", "export function isObject(val) {\n  return typeof val === 'object' && val !== null\n}\n\nexport function isFunction(val) {\n  return typeof val === 'function'\n}\n", "import { isObject } from '@vue/shared'\nimport { activeEffect } from './effect'\nimport { reactive } from './reactive'\n\nexport const enum ReactiveFlags {\n  'IS_REACTIVE' = '__v_isReactive',\n}\n\nexport const mutableHandlers = {\n  get(target, key, receiver) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return true\n    }\n    track(target, key)\n    let result = Reflect.get(target, key, receiver)\n    if (isObject(result)) {\n      return reactive(result)\n    }\n    return result\n  },\n  set(target, key, value, receiver) {\n    let oldValue = target[key]\n    let flag = Reflect.set(target, key, value, receiver)\n    if (value !== oldValue) {\n      trigger(target, key, value, oldValue)\n    }\n    return flag\n  },\n}\n\nconst targetMap = new WeakMap()\nfunction track(target, key) {\n  if (activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n\n    if (!dep) {\n      depsMap.set(key, (dep = new Set()))\n    }\n    trackEffects(dep)\n  }\n}\n\nfunction trigger(target, key, value, oldValue) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) return\n  let effects = depsMap.get(key)\n  triggerEffects(effects)\n}\n\nexport function triggerEffects(effects) {\n  if (effects) {\n    effects = [...effects]\n    effects.forEach((effect) => {\n      if (activeEffect !== effect) {\n        if (effect.scheduler) {\n          effect.scheduler()\n        } else {\n          effect.run()\n        }\n      }\n    })\n  }\n}\n\nexport function trackEffects(dep) {\n  let shouldTrack = !dep.has(activeEffect)\n  if (shouldTrack) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n  }\n}\n", "import { isObject } from '@vue/shared'\nimport { mutableHandlers, ReactiveFlags } from './baseHandler'\n\nexport function reactive(target) {\n  return createReactiveObject(target)\n}\n\nconst reactiveMap = new WeakMap()\n\nfunction createReactiveObject(target) {\n  if (!isObject(target)) return\n  if (target[ReactiveFlags.IS_REACTIVE]) {\n    return target\n  }\n  let existingProxy = reactiveMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  const proxy = new Proxy(target, mutableHandlers)\n  reactiveMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(source) {\n  return !!(source && source[ReactiveFlags.IS_REACTIVE])\n}\n\nexport function toReactive(source) {\n  return isObject(source) ? reactive(source) : source\n}\n", "import { isFunction } from '@vue/shared'\nimport { ReactiveEffect, activeEffect } from './effect'\nimport { trackEffects, triggerEffects } from './baseHandler'\n\nclass ComputedRefImpl {\n  effect\n  _value\n  dep = new Set()\n  _dirty = true\n  constructor(public getter, public setter) {\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        triggerEffects(this.dep)\n      }\n    })\n  }\n  get value() {\n    if (activeEffect) {\n      trackEffects(this.dep)\n    }\n    if (this._dirty) {\n      this._dirty = false\n      this._value = this.effect.run()\n    }\n    return this._value\n  }\n  set value(val) {\n    this.setter(val)\n  }\n}\n\nexport function computed(getterOrOptions) {\n  const isGetter = isFunction(getterOrOptions)\n  let getter\n  let setter\n  if (isGetter) {\n    getter = getterOrOptions\n    setter = () => {\n      console.log('computed is readonly')\n    }\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  return new ComputedRefImpl(getter, setter)\n}\n", "import { isReactive } from './reactive'\nimport { ReactiveEffect, effect } from './effect'\nimport { isFunction, isObject } from '@vue/shared'\n\nfunction traverse(source, seen = new Set()) {\n  if (!isObject(source)) return source\n  if (seen.has(source)) return source\n  seen.add(source)\n  for (let k in source) {\n    traverse(source[k], seen)\n  }\n  return source\n}\n\nfunction doWatch(source, cb, options: any = {}) {\n  let getter\n  if (isReactive(source)) {\n    getter = () => traverse(source)\n  } else if (isFunction(source)) {\n    getter = source\n  }\n  let oldValue\n  let clean\n  const onCleanup = (fn) => {\n    clean = fn\n  }\n  const job = () => {\n    if (cb) {\n      if (clean) clean()\n      const newValue = effect.run()\n      cb(newValue, oldValue, onCleanup)\n      oldValue = newValue\n    } else {\n      effect.run()\n    }\n  }\n  const effect = new ReactiveEffect(getter, job)\n  oldValue = effect.run()\n  if (options.immediate) {\n    job()\n  }\n}\n\nexport function watchEffect(effect, options: any = {}) {\n  doWatch(effect, null, options)\n}\n\nexport function watch(source, cb, options: any = {}) {\n  doWatch(source, cb, options)\n}\n", "import { trackEffects, triggerEffects } from './baseHandler'\nimport { activeEffect } from './effect'\nimport { toReactive } from './reactive'\n\nexport function ref(value) {\n  return new RefImpl(value)\n}\n\nclass RefImpl {\n  _value\n  dep = new Set()\n  constructor(public rawValue) {\n    this._value = toReactive(rawValue)\n  }\n  get value() {\n    if (activeEffect) trackEffects(this.dep)\n    return this._value\n  }\n  set value(newValue) {\n    if (newValue !== this.rawValue) {\n      this.rawValue = newValue\n      this._value = toReactive(newValue)\n      triggerEffects(this.dep)\n    }\n  }\n}\n\nclass ObjectRefImpl {\n  constructor(public object, public key) {}\n  get value() {\n    return this.object[this.key]\n  }\n  set value(val) {\n    this.object[this.key] = val\n  }\n}\n\nexport function toRef(object, key) {\n  return new ObjectRefImpl(object, key)\n}\n\nexport function toRefs(object) {\n  let res = {}\n  for (let key in object) {\n    res[key] = toRef(object, key)\n  }\n  return res\n}\n"],
  "mappings": "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",
  "names": ["effect", "effect", "effect"]
}
